// nFit
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
objref boundvec, weightvec, drand, diamvec, speedvec, graphobj, prand

nefunvec = new Vector()
errlogvec = new Vector()
allerrlogvec = new Vector()
paramquadvec = new Vector()
paramlogvec = new Vector()

strdef pheader, theader, vheader, eheader, alleheader, pnnheader, varstr

fitoff = 1
nefun = 0
nquad = 0
time = 0
newg = 0
// --------------------------------------------------------------------------------



// ----------------------------adjust_injbound-------------------------------------
proc adjust_injbound() {local f, pifdelt localobj tempxvec

	if (!getpifdel()) {
	
		for f = 0, nf-1 {

			if (injvec.x[f]) {

				// search for index in xdat at which x >= pifdel
				pifdelt = RegionFitness[f].xdat.x[RegionFitness[f].xdat.indwhere(">=", getpifdel())]
		
				if (RegionFitness[f].boundary.x[0] < pifdelt) {
		
					RegionFitness[f].boundary.x[0] = pifdelt
					RegionFitness[f].weight.x[0] = 0

					tempxvec = new Vector()
					tempxvec.append(RegionFitness[f].xdat)
					RegionFitness[f].set_modelx(tempxvec)
					
					num = setnsig(pifdelt, 5)
					print "Fit start time adjusted to ", num, "ms for ", FitnessGenerator[0].yvarlist.o(f).s
				}
			}
		}
	}

	tempstr = ""
}
// --------------------------------------------------------------------------------



// ----------------------------adjust_optweight------------------------------------
// assumes a prior call to adjust_injbound(). Experimental. Places a derivative-adjusted
// weight scale on voltage traces.
proc adjust_optweight() {local f, k, pifdeli, pifendi, irange localobj tempvec, tempxvec, tempyvec

	getspeed()

	for f = 0, nf-1 {

		tempyvec = new Vector()
		tempyvec.deriv(RegionFitness[f].ydat, dt, 1)

		RegionFitness[f].boundary.resize(RegionFitness[f].xdat.size)
		RegionFitness[f].weight.resize(RegionFitness[f].xdat.size)

		RegionFitness[f].weight.x[0] = 0

		for k = 0, RegionFitness[f].xdat.size-1 {

			RegionFitness[f].boundary.x[k] = RegionFitness[f].xdat.x[k]
			
			if (k < RegionFitness[f].xdat.size-1) {

				if (abs(tempyvec.x[k]) > speedvec.x[f]) {

					RegionFitness[f].weight.x[k+1] = abs(tempyvec.x[k])/speedvec.x[f]

				} else {

					RegionFitness[f].weight.x[k+1] = 1
				}
			}
		}

		if (injvec.x[f]) {
		
			pifdeli = RegionFitness[f].xdat.indwhere(">=", RegionFitness[f].boundary.x[0])
			pifendi = RegionFitness[f].xdat.indwhere(">=", RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1])

			for k = 0, RegionFitness[f].xdat.size-1 {

				if (RegionFitness[f].boundary.x[k] < pifdeli || RegionFitness[f].boundary.x[k] > pifendi) RegionFitness[f].weight.x[k] = 0
			}
		}

		tempxvec = new Vector()
		tempyvec = new Vector()
		for k = 0, RegionFitness[f].weight.size-1 {

			if (k == 0 || k == RegionFitness[f].weight.size-1) {

				tempxvec.append(RegionFitness[f].boundary.x[k])
				tempyvec.append(RegionFitness[f].weight.x[k])
			
			} else {

				if (RegionFitness[f].weight.x[k] > 1) {

					tempxvec.append(RegionFitness[f].boundary.x[k])
					tempyvec.append(RegionFitness[f].weight.x[k])
				}
			}
		}

		RegionFitness[f].boundary.resize(tempxvec.size)
		RegionFitness[f].weight.resize(tempyvec.size)

		for k = 0, RegionFitness[f].boundary.size-1 {

			RegionFitness[f].boundary.x[k] = tempxvec.x[k]
			RegionFitness[f].weight.x[k] = tempyvec.x[k]
		}

		tempxvec = new Vector()
		tempxvec.append(RegionFitness[f].xdat)
		RegionFitness[f].set_modelx(tempxvec)		
	}
}
// --------------------------------------------------------------------------------



// --------------------------------getspeed----------------------------------------
proc getspeed() {local f, deli, k localobj tempyvec, tempvec

	speedvec = new Vector()

	for f = 0, nf-1 {

		tempyvec = new Vector()

		deli = RegionFitness[f].xdat.indwhere(">=", stim.del)

		for k = 0, deli tempyvec.append(RegionFitness[f].ydat.x[k])

		tempvec = new Vector()

		tempvec.deriv(tempyvec, dt, 1)

		speedvec.append(4*tempvec.stdev())
	}
}
// --------------------------------------------------------------------------------



// ------------------------------croutiampdirman-----------------------------------
proc croutiampdirman() {

	setmodstr(mode)
	sprint(manstr, "outdir")
	crdir(root, manstr)
	sprint(mandir, "%s%s%s", root, manstr, "/")
	crdir(mandir, modstr)
	sprint(moddir, "%s%s%s", mandir, modstr, "/")
	
	if (!numarg()) {

		getampstr()

	} else {

		getampstr($1)
	}
	
	crdir(moddir, ampstr)
	sprint(iampdir, "%s%s%s", moddir, ampstr, "/")
}
// --------------------------------------------------------------------------------



// --------------------------------getpheader--------------------------------------
proc getpheader() {local p

	sprint(pheader, "%s%s", pnamelist.o(0).label, "_norm")
	for p = 1, pnamelist.count-1 sprint(pheader, "%s\t%s%s", pheader, pnamelist.o(p).label, "_norm")
	sprint(pheader, "%s\n", pheader)
}
// --------------------------------------------------------------------------------



// -------------------------------getpnnheader-------------------------------------
proc getpnnheader() {local p

	sprint(pnnheader, "%s", pnamelist.o(0).label)
	for p = 1, pnamelist.count-1 sprint(pnnheader, "%s\t%s", pnnheader, pnamelist.o(p).label)
	sprint(pnnheader, "%s\n", pnnheader)
}
// --------------------------------------------------------------------------------



// -------------------------------geteheader---------------------------------------
proc geteheader() {local f
	
	// construct emat/errlogmat header
	// each col fitvar name, then col total, then tol
	sprint(eheader, "%s", fitvarlist.o(0).label)
	for f = 1, nf-1 sprint(eheader, "%s\t%s", eheader, fitvarlist.o(f).label)
	sprint(eheader, "%s\t%s\t%s\n", eheader, "total", "tol")
}
// --------------------------------------------------------------------------------



// -----------------------------getalleheader--------------------------------------
proc getalleheader() {local f

	// construct allerrlogmat header
	// each col fitvar name, then col total
	sprint(alleheader, "%s", fitvarlist.o(0).label)
	for f = 1, nf-1 sprint(alleheader, "%s\t%s", alleheader, fitvarlist.o(f).label)
	sprint(alleheader, "%s\t%s\n", alleheader, "total")
}
// --------------------------------------------------------------------------------



// -------------------------------getvheader---------------------------------------
proc getvheader() {local f

	// construct vmat header
	// col0 = time, col1,...,coln = v(fit variables)
	sprint(vheader, "%s", "time")
	for f = 0, nf-1 sprint(vheader, "%s\t%s", vheader, fitvarlist.o(f).label)
	sprint(vheader, "%s\n", vheader)
}
// --------------------------------------------------------------------------------



// -------------------------------gettheader---------------------------------------
proc gettheader() {
	
	// construct tmat header
	sprint(theader, "%s\t%s\t%s\t%s\n", "t-tot", "t-each", "avg", "sem")
}
// --------------------------------------------------------------------------------



// -------------------------------getpnnmat----------------------------------------
obfunc getpnnmat() {local p localobj tempmat

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) pmat obj organized in columns"
			print "Output: pnnmat"
			stop
		}
	}

	tempmat = new Matrix($o1.nrow, $o1.ncol)
	getplow()
	for p = 0, tempmat.ncol-1 tempmat.setcol(p, $o1.getcol(p).mul(plowvec.x[p]))

	return tempmat
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc savemanopt() {local f, k, p, nfcount, npcount localobj tempmat, tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will save elements of manually run optimization"
			stop
		}
	}	

	croutiampdirman()

	// save as tmat
	// additonal time statistics also produced here and saved:
	// col0 = time per simulation (seconds)
	// col1 = average
	// col2 = sem = sigma/sqrt(n)
	tempmat = new Matrix(timevec.size, 4)
	for k = 0, tempmat.nrow-1 tempmat.x[k][0] = timevec.x[k]
	if (timevec.size > 1) {
		for k = 0, tempmat.nrow-1 {
			if (!k) {
				tempmat.x[k][1] = tempmat.x[k][0]
			} else {
				tempmat.x[k][1] = timevec.x[k]-timevec.x[k-1]
			}
		}
		tempmat.x[0][2] = tempmat.getcol(0).mean
		tempmat.x[0][3] = tempmat.getcol(0).stderr
	}
	gettheader()
	savemat(iampdir, "tmat.dat", tempmat, tformvec, theader)

	
	// vmat
	tempmat = new Matrix(nrows, nf+1)
	tempmat.setcol(0, tdatvec)
	// copy into vmat the full optimized model traces
	for f = 0, nf-1 {

		// if boundaries are different from default, output full trace v
		if (RegionFitness[f].boundary.x[0] > RegionFitness[f].xdat.x[0] || RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1] < RegionFitness[f].xdat.x[RegionFitness[f].xdat.size-1] || RegionFitness[f].boundary.size > 2) {

			// save previous boundaries
			tempvec = new Vector()
			tempvec.append(RegionFitness[f].boundary)

			// set new (default) boundaries
			RegionFitness[f].boundary = new Vector()
			RegionFitness[f].boundary.append(RegionFitness[f].xdat.x[0], RegionFitness[f].xdat.x[RegionFitness[f].xdat.size-1])
			
			// make these new boundaries effective (must use different xdat vector)
			tempxvec = new Vector()
			tempxvec.append(RegionFitness[f].xdat)
			RegionFitness[f].set_modelx(tempxvec)

			// get default optimized voltage trace
			FitnessGenerator[0].efun()
			tempmat.setcol(f+1, FitnessGenerator[0].yveclist.o(f))

			// restore original bounds
			RegionFitness[f].boundary = new Vector()
			RegionFitness[f].boundary.append(tempvec)
			RegionFitness[f].set_modelx(tempxvec)
		
		} else {

			tempmat.setcol(f+1, FitnessGenerator[0].yveclist.o(f))
		}
	}
	getvheader()
	savemat(iampdir, "vmat.dat", tempmat, vformvec, vheader)

	
	// errlogmat: organized as fit variable0,...,n, total error and tolerance,
	// with the exit code (the start index of the first fitvar err of the last
	// quad) as the last value in the first column
	// save as errlogmat
	tempmat = new Matrix((errlogvec.size-2)/(nf+1)+1, nf+2)
	nfcount = 0
	for k = 0, tempmat.nrow-3 {
		
		for f = 0, nf {

			tempmat.x[k][f] = errlogvec.x[k+f+nfcount*(nf+1)]
		}

		nfcount+=1

		tempmat.x[k][nf+1] = errlogvec.x[errlogvec.size-2]
	}
	tempmat.x[tempmat.nrow-1][0] = errlogvec.x[errlogvec.size-1]
	geteheader()
	savemat(iampdir, "errlogmat.dat", tempmat, vformvec, eheader)

	
	// allerrlogmat: organized as fit variable0,...,n, total error for each fit run.
	// save as allerrlogmat
	tempmat = new Matrix(allerrlogvec.size/(nf+1), nf+1)
	nfcount = 0
	for k = 0, tempmat.nrow-1 {
		
		for f = 0, nf {

			tempmat.x[k][f] = allerrlogvec.x[k+f+nfcount*nf]
		}

		nfcount+=1
	}
	getalleheader()
	savemat(iampdir, "allerrlogmat.dat", tempmat, vformvec, alleheader)


	// emat: organized as fit variable0,...,n, total error and tolerance
	// save as emat 
	tempmat = new Matrix(1, nf+2)
	for f = 0, nf tempmat.x[0][f] = errlogvec.x[errlogvec.size-1-1+errlogvec.x[errlogvec.size-1]+f]
	tempmat.x[0][nf+1] = errlogvec.x[errlogvec.size-2]
	savemat(iampdir, "emat.dat", tempmat, vformvec, eheader)


	// save paramlogmat as p0,...,pn (all opt params), for all iterations
	tempmat = new Matrix(paramlogvec.size/getnp(), getnp())
	npcount = 0
	for k = 0, tempmat.nrow-1 {

		for p = 0, tempmat.ncol-1 {

			tempmat.x[k][p] = paramlogvec.x[p+npcount*tempmat.ncol]
		}

		npcount+=1
	}
	getpheader()
	savemat(iampdir, "paramlogmat.dat", tempmat, maxformvec, pheader)

	
	// save paramquadmat as p0,...,pn (all opt params), for all quads
	// the exit code will be saved on the last row of the first col
	tempmat = new Matrix(((paramquadvec.size-1)/getnp())+1, getnp())
	npcount = 0
	for k = 0, tempmat.nrow-2 {

		for p = 0, tempmat.ncol-1 {

			tempmat.x[k][p] = paramquadvec.x[p+npcount*tempmat.ncol]
		}

		npcount+=1
	}
	tempmat.x[tempmat.nrow-1][0] = paramquadvec.x[paramquadvec.size-1]
	savemat(iampdir, "paramquadmat.dat", tempmat, maxformvec, pheader)

	
	// save pmat as p0,...,pn (all opt params)
	tempmat = new Matrix(1, getnp())
	for p = 0, getnp()-1 {

		tempmat.x[0][p] = paramquadvec.x[p+paramquadvec.size+paramquadvec.x[paramquadvec.size-1]]
	}
	savemat(iampdir, "pmat.dat", tempmat, maxformvec, pheader)

	
	// save pmat-nn, the non-normalized version of pmat
	getpnnheader()
	tempmat = getpnnmat(tempmat)
	savemat(iampdir, "pmat-nn.dat", tempmat, maxformvec, pnnheader)
}
// --------------------------------------------------------------------------------



// ------------------------------saveallerrlogmat----------------------------------
proc saveallerrlogmat() {local f, m, nfcount localobj tempmat

	// construct allerrlogmat header
	// each col fitvar name, then col total
	sprint(alleheader, "%s", fitvarlist.o(0).label)
	for f = 1, nf-1 sprint(alleheader, "%s\t%s", alleheader, fitvarlist.o(f).label)
	sprint(alleheader, "%s\t%s\n", alleheader, "total")

	// create output directory
	croutiampdirman()

	// allerrlogmat: organized as fit variable0,...,n, total error for each fit run.
	// save as allerrlogmat
	tempmat = new Matrix(allerrlogvec.size/(nf+1), nf+1)
	
	nfcount = 0

	for m = 0, tempmat.nrow-1 {

		for f = 0, nf {

			tempmat.x[m][f] = allerrlogvec.x[m+nfcount*nf+f]
		} 
		
		nfcount += 1
	}

	savemat(iampdir, "allerrlogmat.dat", tempmat, vformvec, alleheader)

	// save paramlogmat as p0,...,pn (all opt params), for all iterations
	tempmat = new Matrix(paramlogvec.size/getnp(), getnp())
	npcount = 0
	for k = 0, tempmat.nrow-1 {

		for p = 0, tempmat.ncol-1 {

			tempmat.x[k][p] = paramlogvec.x[p+npcount*tempmat.ncol]
		}

		npcount+=1
	}
	getpheader()
	savemat(iampdir, "paramlogmat.dat", tempmat, maxformvec, pheader)	
}
// --------------------------------------------------------------------------------



// ---------------------------------savepelog--------------------------------------
proc savepelog() {local f, m, k, p, nfcount, npcount localobj tempmat

	// create output directory
	croutiampdirman()

	// allerrlogmat: organized as fit variable0,...,n, total error for each fit run.
	// save as allerrlogmat
	tempmat = new Matrix(allerrlogvec.size/(nf+1), nf+1)
	
	nfcount = 0

	for m = 0, tempmat.nrow-1 {

		for f = 0, nf {

			tempmat.x[m][f] = allerrlogvec.x[m+nfcount*nf+f]
		} 
		
		nfcount += 1
	}
	getalleheader()
	savemat(iampdir, "allerrlogmat.dat", tempmat, vformvec, alleheader)


	// save paramlogmat as p0,...,pn (all opt params), for all iterations
	tempmat = new Matrix(paramlogvec.size/getnp(), getnp())
	npcount = 0
	for k = 0, tempmat.nrow-1 {

		for p = 0, tempmat.ncol-1 {

			tempmat.x[k][p] = paramlogvec.x[p+npcount*tempmat.ncol]
		}

		npcount+=1
	}
	getpheader()
	savemat(iampdir, "paramlogmat.dat", tempmat, maxformvec, pheader)	
}
// --------------------------------------------------------------------------------



// ----------------------------------savepnn---------------------------------------
proc savepnn() {local p, m, pcount localobj tempmat, tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) filename of param mat (normalized)"
			print "2) iamp address within iampvec. if unknown, use getiampind(iamp) [iamp in nA]."
			print "3) row address within param mat containing log of interest. leave blank to obtain entire matrix."
			print "Output: non-normalized param mat of chosen row organized with each parameter in a separate column"
			stop
		}
	}

	getmod()
	getiampdir($2, iampdir)
	getmat(iampdir, $s1, tempmat)

	strf.head($s1, "[.]", headstr)
	strf.tail($s1, "[.]", tailstr)	

	if (numarg() > 2) {

		tempvec = new Vector()		
	
		tempvec.append(tempmat.getrow($3))

		tempmat = new Matrix(tempvec.size, 1)
		tempmat.setcol(0, tempvec)
		tempmat = delzeromat(tempmat)

		tempvec = new Vector()
		tempvec.append(tempmat.getcol(0))

		tempmat = new Matrix(tempvec.size/getnp(), getnp())
		
		pcount = 0

		for m = 0, tempmat.nrow-1 {

			for p = 0, tempmat.ncol-1 {

				tempmat.x[m][p] = tempvec.x[p+pcount*getnp()]
			}

			pcount += 1
		}
		
		sprint(filestr, "%s%g%s%s", headstr, $3, "-nn.", tailstr)
	
	} else {

		sprint(filestr, "%s%s%s", headstr, "-nn.", tailstr)
	}

	getpnnheader()
	tempmat = getpnnmat(tempmat)

	croutiampdirman($2)
	savemat(iampdir, filestr, tempmat, maxformvec, pnnheader)

	filestr = ""
	headstr = ""
	tailstr = ""
}
// --------------------------------------------------------------------------------



// ---------------------------------getnp------------------------------------------
// takes no argument.
// outputs number of parameters entered for simulation.
func getnp() {

	return ParmFitness[0].parmlist.count()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc updparampanel() {local p

	for p = 0, getnp()-1 pvec.x[p] = RunFitParm[p].val * plowvec.x[p]
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// update param and error log if fit present
proc updpelog() {local f, p, yfitsize, ydatsize

	yfitsize = 0
	ydatsize = 0

	for f = 0, nf-1 {

		yfitsize += FitnessGenerator[0].yveclist.o(f).size
		ydatsize += RegionFitness[f].ydat_.size
	}

	if (yfitsize == ydatsize) {

		for p = 0, getnp()-1 paramlogvec.append(RunFitParm[p].val)
		for f = 0, nf-1 allerrlogvec.append(RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_))
		allerrlogvec.append(allerrlogvec.c(allerrlogvec.size-nf, allerrlogvec.size-1).sum)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// updates both pnorm and corresponding RunFitParm with pnorm arguments of different type
proc updfitparam() {local p, i, k

	if (argtype(1) == 1) {

		// whole vector input
		if (numarg() == 1) {

			if (argtype(1) == 1) {

				for p = 0, $o1.size-1 {

					RunFitParm[p].val = $o1.x[p]
					setpnorm(p, $o1.x[p])
				}
			}

		// vector + vector range from $2 to $3 as input 
		} else if (numarg() == 3) {

			if (argtype(1) == 1) {

				for k = 0, $o1.size-1 {

					RunFitParm[k+$2].val = $o1.x[k]
					setpnorm(k+$2, $o1.x[k])
				}
			}
		}
	
	// input as individual parameters 
	} else {

		for i = 1, numarg() {

			RunFitParm[i-1].val = $i
			setpnorm(i-1, $i)
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// check number of RunFitParm variables against number that should be present, 
// based on setnp(), and fixes these accordingly. Should be run once before opts.
proc updrfp() {local k, tempnum

	getpnorm()
	getplow()
	getphi()
	getdoarg()
	getuselog()

	tempnum = ParmFitness[0].parmlist.count

	for k = 0, pnormvec.size-1 {

		if (k < tempnum) {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")
			if (uselogvec.x[k]) {
				ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			} else {
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
					ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}

			tempobj = ParmFitness[0].parmlist.o(k)
			tempobj.setname(tempstr)
			ParmFitness[0].parmlist.remove(k)
			ParmFitness[0].parmlist.insrt(k, tempobj)
			objref tempobj
			objref domainbox, domainlist, parmbox

		} else {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")
			tempobj = new RunFitParm(tempstr)
			if (uselogvec.x[k]) {
				tempobj.set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			} else {
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
					tempobj.set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}
			ParmFitness[0].declare(tempobj)
			ParmFitness[0].parmlist.append(tempobj)
			objref domainbox, domainlist, parmbox
			if (strf.head(tempstr, "\\$", teststr) == -1) {
				sprint(tempstr, "%s.val = %s", tempobj, tempstr)
				execute1(tempstr)
			}
		}
	}

	if (pnormvec.size < ParmFitness[0].parmlist.count) {

		tempnum = ParmFitness[0].parmlist.count - pnormvec.size

		k = 0
		while (k < tempnum) {

			ParmFitness[0].parmlist.remove(ParmFitness[0].parmlist.count-1)
			objref domainbox, domainlist, parmbox
			k += 1
		}
	}

	ParmFitness[0].def_parmlist_use()

	tempstr = ""
	objref tempobj
}
// --------------------------------------------------------------------------------



// -------------------------------showdom------------------------------------------
proc showdom() {

	ParmFitnessGui[0].showdomain(1581, 729, 272.64, 213.12)
}
// --------------------------------------------------------------------------------



// ------------------------------initfit-------------------------------------------
// takes no argument.
// resets parameter panel values to default. Do not use in parallel contexts.
proc initfit() {

	nquad = 0
	nefun = 0
	nefunvec = new Vector()
	time = 0
	timevec = new Vector()
	errlogvec = new Vector()
	allerrlogvec = new Vector()
	paramquadvec = new Vector()
	paramlogvec = new Vector()
}
// --------------------------------------------------------------------------------



// ------------------------------initpnormdef--------------------------------------
proc initpnormdef() {local p

	for p = 0, getnp()-1 {

		RunFitParm[p].val = pnormdefvec.x[p]
		setpnorm(p, pnormdefvec.x[p])
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) iiamp
// changes fit data according to iamp position in iampvec and imported vdat
proc changedata() {local f localobj boundvec, weightvec, tempxvec

	for f = 0, nf-1 {

		// store already set bounds, if different from default
		if (RegionFitness[f].boundary.x[0] != RegionFitness[f].xdat.x[0] || RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1] != RegionFitness[f].xdat.x[RegionFitness[f].xdat.size-1] || RegionFitness[f].boundary.size > 2) {

			// store those bounds in boundvec
			boundvec = new Vector()
			boundvec.append(RegionFitness[f].boundary)
			// also store the associated weights in weightvec
			weightvec = new Vector()
			weightvec.append(RegionFitness[f].weight)

			// set data to new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))

			// restore previous boudaries and weights (the associated dw get taken care of)
			RegionFitness[f].boundary = new Vector()
			RegionFitness[f].boundary.append(boundvec)
			RegionFitness[f].weight = new Vector()
			RegionFitness[f].weight.append(weightvec)

			// to finalize the restoration in the GUI, need...
			tempxvec = new Vector()
			tempxvec.append(RegionFitness[f].xdat)
			RegionFitness[f].set_modelx(tempxvec)
		
		} else {

			// if already set bounds same as default, simply change data for new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))
		}
	}

	print "Fit data changed to ", iampvec.x[$1]*1000, "pA voltage response"

	adjust_injbound()
}
// --------------------------------------------------------------------------------



// -------------------------------optimize-----------------------------------------
// takes optional (1) tol, (2) maxstepsize. 
// a "just-enough" approach to optimization ideal for unevenly- distributed 
// parameters, such as myelin over the axon only, or weakly-constrained parameters 
// in general, due to intrinsic noise or other factors. optimizes input  parameters 
// using Brent's praxis algorithm with a tolerance-based exit strategy.
proc optimize() {local p, f

	// variable tracking whether this optimize procedure is running
	fitoff = 0
	// minimum nquad
	MulfitPraxWrap[1].nstep = 1
	// set attributes of praxis
	if (numarg() == 2) {
		tol = $1
		maxstepsize = $2
	}
	attr_praxis(tol, maxstepsize, 0)
	// start optimize. Stop button needs to be pressed twice on the gui to exit.
	MulRunFitter[0].prun()

	// exit strategy
	while (!fitoff) {

		if (stoprun) {
		
			nquad = 0
			nefun = 0
			nefunvec = new Vector()
			time = 0
			timevec = new Vector()
			errlogvec = new Vector()
			allerrlogvec = new Vector()
			paramquadvec = new Vector()
			paramlogvec = new Vector()
			fitoff = 1
			break
		 
		} else {

			// optimization variables of interest
			nquad += 1
			nefunvec.append(MulRunFitter[0].opt.nefun)
			time += MulRunFitter[0].opt.time			
			if (time) timevec.append(time)
			// error and parameter logging
			for f = 0, nf-1 errlogvec.append(RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_))
			errlogvec.append(errlogvec.c(errlogvec.size-nf, errlogvec.size-1).sum)
			for p = 0, getnp()-1 paramquadvec.append(RunFitParm[p].val)
			
			// Here, if the error is in the noise...
			if (errlogvec.x[errlogvec.size-1] < tol) {

				nefun = nefunvec.sum
				print "total: nquad=", nquad, "nefun=", nefun, "time=", time, "e=", MulfitPraxWrap[1].minerr
				print "Optimization completed"
				// exit codes
				errlogvec.append(tol)
				errlogvec.append(-1-1-1)
				paramquadvec.append(-getnp()-1)
				fitoff = 1

			} else if (errlogvec.size > 2*(nf+1)) {
			
				// NEURON does not allow the merging of these just above and just below conditions because 
				// it checks each one even if one of them - in this case the first - is false. In other words,
				// it will check the first, it is false, does not exit the condition, goes on to check the second,
				// which may throw an error because errlogvec is not that size yet...
				// Here, if the error improvement is in the noise...
				if (abs(errlogvec.x[errlogvec.size-1] - errlogvec.x[errlogvec.size-2-nf]) < tol) {
			
					// NEURON cannot handle compound conditional statements in general (it probably does not recognize the internal bracket delimiter). Therefore, each boolean binary 
					// substatement must be separately determined, i.e. if (A && (B || C)) is not possible. One must instead write: if (A) -> if (B || C).
					// Here, if the error improvement is marginal...
					if (abs(errlogvec.x[errlogvec.size-1] - errlogvec.x[errlogvec.size-2-nf]) < abs(errlogvec.x[errlogvec.size-2-nf] - errlogvec.x[errlogvec.size-3-2*nf]) || abs(errlogvec.x[errlogvec.size-1] - errlogvec.x[errlogvec.size-2-nf]) < 1e-6) {
						
						updfitparam(paramquadvec.c(paramquadvec.size-2*getnp(), paramquadvec.size-getnp()-1))
						FitnessGenerator[0].efun()
						nquad -= 1
						nefun = nefunvec.sum-nefunvec.x[nefunvec.size-1]
						print "total: nquad=", nquad, "nefun=", nefun, "time=", time, "e=", errlogvec.x[errlogvec.size-nf-1-1]
						print "Optimization completed"
						// exit codes
						errlogvec.append(tol)
						errlogvec.append(-nf-1-1-1-1)
						paramquadvec.append(-2*getnp()-1)
						fitoff = 1
					}
				}

			} else {
			
				nefun = nefunvec.sum
				print "total: nquad=", nquad, "nefun=", nefun, "time=", time, "e=", MulfitPraxWrap[1].minerr
				optimize(tol, maxstepsize)
			}
		}
	}
}
// --------------------------------------------------------------------------------



// -----------------------------optimizewrap---------------------------------------
proc optimizewrap() {

	initfit()

	if (numarg() == 2) {

		optimize($1, $2)
	
	} else {

		optimize()
	}
}
// --------------------------------------------------------------------------------



// -----------------------------setoptpanel----------------------------------------
proc setoptpanel() {

	optibox = new VBox(3)
	optibox.intercept(1)
	xpanel("", 1)
	xbutton("optimize", "optimizewrap()")
	xlabel(" for non-uniform parameter distributions")
	xpanel()
	xpanel("", 1)
	xpvalue("nquad", &nquad, 0, "", 0, 1)
	xlabel(" ")
	xpvalue("nefun", &nefun)
	xpanel()
	optibox.intercept(0)
	optibox.map("Non-uniform optimization", 612, 966, 360.96, 93.12)
}
// --------------------------------------------------------------------------------



// -----------------------------getiampdir-----------------------------------------
proc getiampdir() {local amplitude

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) iamp address within iampvec. if unknown, use getiampind(iamp) [iamp in nA]."
			print "2) iampdir (str), into which iampdir address will be printed"
			stop
		}
	}
	
	amplitude = setnsig(iampvec.x[$1]*1000, 3)
	
	if (amplitude >= 0) {
		sprint(ampstr, "%s%g%s", "+", amplitude, "pA")
	} else {
		sprint(ampstr, "%g%s", amplitude, "pA")
	}

	getmod()

	sprint($s2, "%s%s%s", moddir, ampstr, "/")	
}
// --------------------------------------------------------------------------------



// ----------------------------getmoddir-------------------------------------------
proc getmoddir() {

	sprint(modstr, "%s%s%s", modeltypestr, "-", axontypestr)
	sprint(moddir, "%s%s%s", out, modstr, "/")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc perr() {local f

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each fit error sequentially."
			stop
		}
	}

	for f = 0, nf-1 {

		sprint(numstr, vformvec, RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_))
		sprint(tempstr, "%s%s", tempstr, numstr)
	}

	print tempstr

	numstr = ""
	tempstr = ""
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc ppnorm() {local k, np_pas

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each pnorm."
			stop
		}
	}

	np_pas = setnp(0)
	setnp(mode)

	for k = np_pas, pnormvec.size-1 print pnormvec.x[i]
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getsecparam() {local seg, countseg, pos, nrecrows, k localobj tempvec, tempmat

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) section name (string) or sectionlist (object)"
			print "2) variable of interest to record, e.g. v or vext (string)"
			print "3) optional file name header (string, i.e. sectionlist name)"
			stop
		}
	}

	countseg = 0
	if (argtype(1) == 2) {

		forsec $s1 countseg = nseg 
	
	} else {

		forsec $o1 countseg += nseg
	}

	nrecrows = tstop/dt
	tempvec = new Vector(1, nrecrows)
	tempvec.floor
	nrecrows = tempvec.x[0]+1
	crveclist(countseg+1, templist)
	for k = 0, templist.count-1 templist.o(k).resize(nrecrows)

	strdef exprtok_left, exprtok_right
	if (!strcmp($s2, "v")) sprint(exprtok_left, ".v(")
	if (!strcmp($s2, "vext")) sprint(exprtok_left, ".vext(")
	sprint(exprtok_right, ")")	
	
	templist.o(0).record(&t)
	num = 1
	strdef getsecparamstr
	if (argtype(1) == 2) {

		forsec $s1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", $s1, exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", secname(), exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}
	}

	init()
	run()

	getmod()
	if (numarg() == 3 && argtype(3) == 2) {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s%s%s", $s3, "_", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s%s%s", $s3, "_", $s2, "_", modstr, ".dat")	
		}

	} else {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s", $s2, "_", modstr, ".dat")	
		}				
	}
	
	tempmat = new Matrix(nrecrows, countseg+1)
	for k = 0, templist.count-1 tempmat.setcol(k, templist.o(k))
	savemat(ses, tempstr, tempmat, vformvec)

	objref templist
	tempstr = ""
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc gadd() {local seg, pos

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) section (string) or sectionlist (object) to plot"
			print "2) variable of interest to plot (string), e.g. \"v\" or \"vext\""
			stop
		}
	}

	strdef exprtok_left, exprtok_right
	if (!strcmp($s2, "v")) sprint(exprtok_left, ".v(")
	if (!strcmp($s2, "vext")) sprint(exprtok_left, ".vext(")
	sprint(exprtok_right, ")")
	
	if (!newg) {

		graphobj = new Graph(0)
		graphobj.size(-1e-7, tstop, -80, 40)
		graphobj.view(-1e-7, -80, tstop, 120, 612, 726, 678.72, 277.12)		
		newg = 1
	
	} else {

		graphobj.erase_all()
	}

	if (argtype(1) == 2) {
	
		forsec $s2 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", $s2, exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", secname(), exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}
	}

	graphList[0].append(graphobj)
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc chlam() {local k localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) expected number of lamellae, e.g. 16"
			print "2) base multiple for changing this, e.g. 2 or 10"
			print "3) start power range (>= 0), ex: 0"
			print "4) end power range, ex: 6"
			print "5) desired sectionlist (object) or section name (string) to record"
			print "6) variable of interest (string). Ex: \"v\" or \"vext\""
			print "7) optional filename header (string)"
			stop
		}
	}

	tempvec = new Vector(3, 0)

	tempvec.x[0] = Cmy_norm * $1 * 2
	tempvec.x[1] = Rmy_norm/($1 * 2)
	tempvec.x[2] = (smy-1)/($1 * 2)

	for k = 0, $4-$3 {

		Cmy_norm = tempvec.x[0]/(($2^($3+k))*2)
		Rmy_norm = tempvec.x[1] * (($2^($3+k))*2)
		smy = 1 + tempvec.x[2] * (($2^($3+k))*2)

		getpnorm()
		updfitparam(pnormvec)
		init()

		strdef lamstr
		sprint(lamstr, "%s%g", "lamellae = ", $2^($3+k))
		if (numarg() == 7) {

			sprint(lamstr, "%s%s%s", $s7, ", ", lamstr)

		} else {

			sprint(lamstr, "%s%s", "_", lamstr)			
		}
		
		if (argtype(5) == 2) {

			getsecparam($s5, $s6, lamstr)
	
		} else {

			getsecparam($o5, $s6, lamstr)
		}
	}

	Cmy_norm = tempvec.x[0]/($1 * 2)
	Rmy_norm = tempvec.x[1] * ($1 * 2)
	smy = (tempvec.x[2] * $1 * 2) + 1

	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta1() {local mpa, mpn, apa, apn, k, delta_pa, delta_pn

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired delta_pa (nm)"
			print "2) desired delta_pn (nm)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4

	if (!chgdelta1) {

		dpa = getdiam(interparanodal)
		apa = PI*delta_pa*(1e-7)*(dpa*(1e-4)+delta_pa*(1e-7))
		Rpa = rpa_norm * rpa_low * (1e6) * apa

		dpn = getdiam(paranodal)
		apn = PI*delta_pn*(1e-7)*(dpn*(1e-4)+delta_pn*(1e-7))
		Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn

		rpa_norm_orig = rpa_norm

		chgdelta1 = 1
	}
	
	mpa = $1/delta_pa
	apa = PI*delta_pa*(1e-7)*mpa*(dpa*(1e-4)+delta_pa*(1e-7)*mpa)
	rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
	
	mpn = $2/delta_pn
	apn = PI*delta_pn*(1e-7)*mpn*(dpn*(1e-4)+delta_pn*(1e-7)*mpn)	
	parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm_orig

	getpnorm()
	updfitparam(pnormvec)

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta() {local delta_pa, delta_pn

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired submyelin space to change the radius of (string), e.g. \"pa\", \"pn\", or \"papn\""
			print "2) base multiple to effect this change, ex: 2, 10, etc"
			print "3) the power range start, ex: -2"
			print "4) the power range end, ex: 3"
			print "5) the desired sectionlist (object) or section name (string) to record"
			print "6) the variable of interest (string), e.g. \"v\" or \"vext\""
			print "7) a file name header (string)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4
	strdef chdelta_header

	for k = 0, $4-$3 {

		if (!strcmp($s1, "pa")) {
			
			chdelta1(($2^($3+k))*delta_pa, delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm")
		}

		if (!strcmp($s1, "pn")) {
			
			chdelta1(delta_pn, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pn, " nm")
		}

		if (!strcmp($s1, "papn")) {
			
			chdelta1(($2^($3+k))*delta_pa, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm and ", ($2^($3+k))*delta_pn, " nm")
		}		

		if (argtype(5) == 2) {
		
			getsecparam($s5, $s6, chdelta_header)

		} else {

			getsecparam($o5, $s6, chdelta_header)
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local dpa, dpn, apa, apn, Rpa, Rpn, k, rpa_norm_orig, parafact_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) base multiple for changing delta, e.g. 2 or 10"
			print "2 & 3) the power range, e.g. -2, 2"
			print "4) the desired sectionlist to record"
			print "5) the variable of interest. Ex: v or vext"
			print "6) an optional filename header"
			stop
		}
	}

	dpa = getdiam(interparanodal)
	dpn = getdiam(paranodal)
	
	apa = PI*12.3*(1e-7)*(dpa*(1e-4)+12.3*(1e-7))
	apn = PI*7.4*(1e-7)*(dpn*(1e-4)+7.4*(1e-7))
	
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn
	
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	parafact_norm_orig = parafact_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $3-$2 {

		apa = PI*12.3*(1e-7)*($1^($2+k))*(dpa*(1e-4)+12.3*(1e-7)*($1^($2+k)))
		apn = PI*7.4*(1e-7)*($1^($2+k))*(dpn*(1e-4)+7.4*(1e-7)*($1^($2+k)))

		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm

		Rmy_norm = (Rmy/((0.5*(dpa+dpn))/((0.5*(dpa+dpn)) + 2*(0.5*(dpa+dpn)*$1^($2+k)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)

		sprint(varstr, "%s%g", "new delta *= ", ($1^($2+k)))

		if (numarg() == 6 && argtype(6) == 2) sprint(varstr, "%s%s%s", $s6, ", ", varstr)
		
		getsecparam($s5, $o4, varstr)
	}

	rpa_norm = rpa_norm_orig
	parafact_norm = parafact_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local ad, apa, Rpa, k, rpa_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) an expected delta (nm), e.g. 12.3 Current rpa corresponds to base delta_pa."
			print "2) a base multiple for changing delta, e.g. 2 or 10"
			print "3 & 4) the power range, e.g. -2, 2"
			print "5) the desired sectionlist to record"
			print "6) the variable of interest. Ex: v or vext"
			print "7) an optional filename header"
			stop
		}
	}

	ad = getdiam(internodal)
	apa = PI*12*(1e-7)*(ad*(1e-4)+12*(1e-7))
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $4-$3 {

		apa = PI*12*(1e-7)*(1/12)*(ad*(1e-4)+12*(1e-7)*(1/12))
		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		Rmy_norm = (Rmy/(ad/(ad + 2*(12*(1/12)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)
		init()

		sprint(varstr, "%s%g%s%g%s", "base delta_pa = ", $1, "nm, new delta_pa = ", $1*($2^($3+k)), "nm")

		if (numarg() == 7 && argtype(7) == 2) sprint(varstr, "%s%s%s", $s7, ", ", varstr)
		
		getsecparam($s6, $o5, varstr)
	}

	rpa_norm = rpa_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chparam() {local k localobj tempvec, paramvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) the parameter of interest (string), e.g. \"Ri\""
			print "2) the base multiple for fold changes, e.g. 2 or 10"
			print "3) the start range of the number of fold changes, e.g. -5"
			print "4) the end range of the number of fold changes, e.g. 5"
			print "5) the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			print "6) the desired variable to record (string), e.g. \"v\" or \"vext\""
			print "7) an optional file header"

			print "\nHere is the list of available parameters:"
			for k = 0, pnamelist.count-1 print pnamelist.o(k).label
			stop
		}
	}

	tempvec = new Vector(2, 0)

	for k = 0, pnamelist.count-1 {

		if (!strcmp($s1, pnamelist.o(k).label)) {

			tempvec.x[0] = k
			k = pnamelist.count-1
		}
	}
	tempvec.x[1] = pnormvec.x[tempvec.x[0]]

	paramvec = new Vector($4-$3+1, 0)

	for k = 0, $4-$3 {

		paramvec.x[k] = tempvec.x[1] * $2^($3+k)

		pnormvec.x[tempvec.x[0]] = paramvec.x[k]
		updfitparam(pnormvec)
		init()

		strdef header
		sprint(header, "%s%s%g%s%s", $s1, "=", ($2^($3+k)), "*", $s1)

		if (numarg() == 7 && argtype(7) == 2) sprint(header, "%s%s%s", $s7, ", ", header)

		if (argtype(5) == 1) {
			
			getsecparam($s6, $o5, header)
		
		} else if (argtype(5) == 2) {

			getsecparam($s6, $s5, header)
		
		} else {

			print "Error: enter the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			stop
		}
	}

	savepelog()

	pnormvec.x[tempvec.x[0]] = tempvec.x[1]
	updfitparam(pnormvec)
	init()

	tempstr = ""
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getthresh() {local dx localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) time vector"
			print "2) voltage vector"
			print "3) desired dV/dt threshold (V/s)"
			print "Returns threshold onset (time vector units)"
			stop
		}
	}

	dx = ($o1.x[$o1.size-1]-$o1.x[0])/($o1.size-1)

	tempvec = new Vector()

	tempvec.deriv($o2, dx, 1)

	return $o1.x[tempvec.indwhere(">=", $3)]
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdiam() {local k, m localobj diamvec, tempvec, drand

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) sectionlist"
			print "2) diameter slice to add or remove from each measurement in given sectionlist in um (e.g. 0.3 um)"
			stop
		}
	}

	diamvec = new Vector()
	forsec $o1 for (x, 0) diamvec.append(diam(x))

	drand = new Random()
	drand.normal(0, 1)

	tempvec = new Vector()
	for k = 0, diamvec.size-1 tempvec.append(diamvec.x[k] + drand.repick()*$2)

	m = -1
	forsec $o1 for (x, 0) {

		m += 1
		diam(x) = tempvec.x[m]
	}

	print "DIAMETER CHANGE ACTIVATED"
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc randomizep() {local k localobj prand, tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Randomize parameter range (0, np-1) within parameter bound (plow, phi)"
			print "Enter:"
			print "1) start range, i.e. 0 or 8"
			print "2) end range, i.e. getnp()-1"
			print "3) optional: randomization seed (0-n). Default = 0."
			stop
		}
	}

	if (numarg() == 3) {
		prand = new Random($3)
	} else {
		prand = new Random()
	}
	tempvec = new Vector()

	getplow()
	getphi()

	for k = $1, $2 {

		prand.uniform(1, phivec.x[k]/plowvec.x[k])
		tempvec.append(prand.repick())
	}

	updfitparam(tempvec, $1, $2)

	init()
}
// --------------------------------------------------------------------------------
