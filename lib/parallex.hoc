// nFit
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------------Variables------------------------------------------
objref rpmat, pspacemat
objref mutmat, permvec
objref errlogvecout, paramquadvecout, paramlogvecout, rangemat

strdef mutstart, mutp, mutcom, mutend, mutexec
// ----------------------------------------------------------------------------------------



// --------------------------------------setgen--------------------------------------------
// set gene regions i.e. the domains in parameter space, from which a randomly chosen base, 
// or initial condition, will be mutated and expressed. Excludes the very weakly-constrained 
// Cpip, which will still be optimized, but as a "silent" gene.
proc setgen() {local m, p

	// parameter space divisions, or genes
	pspacemat = new Matrix(nd+1, getnp()-1)

	getplow()
	getphi()

	for m = 0, pspacemat.nrow-1 {
		
		for p = 0, pspacemat.ncol-1 pspacemat.x[m][p] = 1 + m*(((phivec.x[p]/plowvec.x[p])-1)/nd)
	}
}
// ---------------------------------------------------------------------------------------



// -----------------------------------getmutation-----------------------------------------
// procedure for getting  mutation possibilities, which are really just
// permutations of all possible pspace row indices (row = 0, row = nrow-2).
// i.e. if nd = 2, there are 2 possible pspace rows indices, representing
// the 2 states of the variable: (row = 0, row = 1) and (row = 1, row = 2).
proc getmutation() {local k localobj tempvec

	tempvec = new Vector(getnp()-1, 0)
	mutmat = new Matrix(ns, tempvec.size)

	if (nd == 1) {
		
		for k = 0, mutmat.nrow-1 {

			// all zeros; zero means no mutation will be made
			mutmat.setrow(k, tempvec)
		}
	
	} else {

		for k = 0, tempvec.size-1 {

			sprint(mutstart, "%s%s%d%s", mutstart, "for p", k, " = 0, nd-1 {\n")
			sprint(mutp, "%s%s%d%s", mutp, "p", k, ",")
			sprint(mutend, "%s%s", mutend, "}\n")
		}

		strf.left(mutp, strf.len(mutp)-1)
		sprint(mutcom, "%s%s%s", "permvec = new Vector()\npermvec.append(", mutp, ")\nmutmat.setrow(mutsim, permvec)\nmutsim+=1\n")
		sprint(mutexec, "%s%s%s", mutstart, mutcom, mutend)

		mutsim = 0
		execute(mutexec)
	}

	mutstart = ""
	mutp = ""
	mutcom = ""
	mutend = ""
	mutexec = ""
	mutsim = 0
}
// ---------------------------------------------------------------------------------------



// --------------------------------------mutate-------------------------------------------
// procedure for mutating initial conditions.
// takes seed argument for rng.
proc mutate() {local p, sim localobj prand

	// randomized parameter matrix
	rpmat = new Matrix(ns, getnp()-1)
	prand = new Random($1)
	
	sim = 0
	while (sim < rpmat.nrow) {

		for p = 0, pspacemat.ncol-1 {

			// if mutmat.x[row sim][col p] => start (and therefore end) rows from which to pick
			// prand range.
			prand.uniform(pspacemat.x[mutmat.x[sim][p]][p], pspacemat.x[mutmat.x[sim][p]+1][p])
			rpmat.x[sim][p] = prand.repick()
		}
		
		sim += 1
	}
}
// ---------------------------------------------------------------------------------------



// -----------------------------------adjust_rp-------------------------------------------
// add the default simulation (def parameters) at row 0 and last column Cpip.
// also ensure compatibility with computational efficiency of at most 1024 simulations 
// per current injection
proc adjust_rp() {local sim, reduction_factor, simcount localobj tempmat, tempvec

	tempmat = new Matrix(rpmat.nrow+1, rpmat.ncol+1)
	getpnormdef()
	tempmat.setrow(0, pnormdefvec)

	for sim = 1, tempmat.nrow-1 {

		tempmat.setrow(sim, rpmat.getrow(sim-1))
		tempmat.x[sim][tempmat.ncol-1] = Cpip_norm_def
	}

	if (ns > simax) {

		tempvec = new Vector()
		tempvec.append(ns/simax)
		tempvec.floor()
		reduction_factor = tempvec.x[0]-1
		
		rpmat = new Matrix(simax+1, tempmat.ncol)
		rpmat.setrow(0, tempmat.getrow(0))

		for sim = 1, rpmat.nrow-1 {

			rpmat.setrow(sim, tempmat.getrow(sim*(reduction_factor+1)))
		}
	
	} else {

		rpmat = new Matrix(tempmat.nrow, tempmat.ncol)
		for sim = 0, rpmat.nrow-1 rpmat.setrow(sim, tempmat.getrow(sim))
	}
}
// ---------------------------------------------------------------------------------------



// -----------------------------------croutmat--------------------------------------------
proc croutmat() {

	// voltage
	vmat = new Matrix(nrows, nf*$1)
	// error
	emat = new Matrix($1, nf+2)
	// optimized parameters
	pmat = new Matrix($1, getnp())
	// sim time
	tmat = new Matrix($1, 1)
	// errloglist
	crveclist($1, errloglist)
	// paramquadlist
	crveclist($1, paramquadlist)
	// paramloglist
	crveclist($1, paramloglist)
}
// ---------------------------------------------------------------------------------------



// ----------------------------------croutdir---------------------------------------------
// create output directory if it does not already exist
proc croutdir() {local chk

	chk = chkcwd(cwd)
	if (chk) cwd = getcwd()

	// check if output dir exists
	chdir(root)
	tempstr = ""
	system("ls", tempstr)
	if (strf.substr(tempstr, "outdir\n") == -1) {

		// create output dir
		system("mkdir outdir")
		print "Output directory \"outdir\" created"
	}

	tempstr = ""
	
	chdir(cwd)
	if (chk) cwd = ""
}
// ---------------------------------------------------------------------------------------



// -----------------------------------croutmoddir-----------------------------------------
proc croutmoddir() {local chk

	chk = chkcwd(cwd)
	if (chk) cwd = getcwd()
	
	sprint(modstr, "%s%s%s", modeltypestr, "-", axontypestr)
	sprint(moddir, "%s%s%s", out, modstr, "/")	

	chdir(out)
	tempstr = ""
	system("ls", tempstr)

	sprint(teststr, "%s%s", modstr, "\n")
	
	if (strf.substr(tempstr, teststr) == -1) {

		sprint(tempdir, "%s%s", "mkdir ", modstr)
		system(tempdir)
		print "Model directory \"", modstr, "\" created"
	}

	tempstr = ""
	tempdir = ""

	chdir(cwd)
	if (chk) cwd = ""
}
// ---------------------------------------------------------------------------------------



// ----------------------------------croutiampdir-----------------------------------------
// create output iamp directories, if they don't already exist
proc croutiampdir() {local chk, amplitude

	chk = chkcwd(cwd)
	if (chk) cwd = getcwd()
	
	amplitude = setnsig(iampvec.x[$1]*1000, 3)
	if (amplitude >= 0) {
		sprint(ampstr, "%s%g%s", "+", amplitude, "pA")
	} else {
		sprint(ampstr, "%g%s", amplitude, "pA")
	}

	chdir(moddir)
	tempstr = ""
	system("ls", tempstr)
	
	if (strf.substr(tempstr, ampstr) == -1) {
		
		sprint(tempdir, "%s%s%s", "mkdir ", "./", ampstr)
		system(tempdir)
	}

	// create iampdir
	sprint(iampdir, "%s%s%s", moddir, ampstr, "/")

	tempstr = ""
	tempdir = ""
	
	chdir(cwd)
	if (chk) cwd = ""
}
// ---------------------------------------------------------------------------------------



// ------------------------------------saveopt--------------------------------------------
// save the results from parallex
// $1 = scount
// $o1 = rangemat
// $o2 = pmat
// $o3 = emat
// $o4 = tmat
// $o5 = vmat
// $o6 = errloglist -> errlogmat
// $o7 = paramquadlist -> paramquadmat
// $o8 = paramloglist -> paramlogmat
proc saveopt() {local f, k, r, q, sim, scount, istart, qstart localobj tempmat, tempvec

	scount = $1
	istart = -1

	// construct emat header
	// each col fitvar name, then col total, then tol
	sprint(eheader, "%s", fitvarlist.o(0).label)
	for f = 1, nf-1 sprint(eheader, "%s\t%s", eheader, fitvarlist.o(f).label)
	sprint(eheader, "%s\t%s\t%s\n", eheader, "total", "tol")

	// construct tmat header
	// col0 = time, col1 = avg, col2 = sem
	sprint(theader, "%s\t%s\t%s\n", "time", "avg", "sem")

	// construct vmat header
	// col0 = time, col1,...,col(nf*(scount+1)) fitvarname(f)
	sprint(vheader, "%s", "time")
	for sim = 0, scount {
		for f = 0, nf-1 {

			sprint(vheader, "%s\t%s", vheader, fitvarlist.o(f).label)
		}
	}
	sprint(vheader, "%s\n", vheader)

	// if parallel simulation...
	if (numarg() > 2) {

		for r = 0, $o2.ncol-1 {

			for k = $o2.x[0][r], $o2.x[1][r] {

				istart += 1

				getiampdir(k, iampdir)

				// break up aggregate matrices into iamp-based components
				// pmat: organized iamp::0-scount
				// save as pmat
				tempmat = new Matrix(scount+1, getnp())
				for sim = 0, scount tempmat.setrow(sim, $o3.getrow(istart*(scount+1)+sim))
				// 3d() information is overly-precise; set it to float epsilon
				savemat(iampdir, "pmat.dat", tempmat, maxformvec, pheader)

				// emat: organized iamp::0-scount
				// save as emat
				tempmat = new Matrix(scount+1, nf+2)
				for sim = 0, scount tempmat.setrow(sim, $o4.getrow(istart*(scount+1)+sim))
				savemat(iampdir, "emat.dat", tempmat, vformvec, eheader)

				// tmat: organized iamp::0-scount
				// save as tmat
				// additonal time statistics also produced here and saved:
				// col0 = time per simulation (hours)
				// col1 = average
				// col2 = sem = sigma/sqrt(n)
				tempmat = new Matrix(scount, 3)
				qstart = istart*(scount+1)
				for q = 0, tempmat.nrow-1 tempmat.x[q][0] = $o5.x[qstart+q][0]
				tempmat.x[0][1] = tempmat.getcol(0).mean
				tempmat.x[0][2] = tempmat.getcol(0).stderr
				savemat(iampdir, "tmat.dat", tempmat, tformvec, theader)

				// vmat: organized f:nf::0-scount::iamp (in cols, first col tdat)
				// save as vmat with first col tdat, cols 1-nf*(scount+1) as before: f:nf.
				tempmat = new Matrix(nrows, nf*(scount+1)+1)
				tempmat.setcol(0, tdatvec)
				for sim = 0, scount {
					for f = 0, nf-1 {

						tempmat.setcol(nf*sim+f+1, $o6.getcol(istart*nf*(scount+1)+nf*sim+f))
					}
				}
				savemat(iampdir, "vmat.dat", tempmat, vformvec, vheader)

				// errlogmat: organized as iamp::0-scount (but of differing sizes)
				// save as errlogmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append($o7.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q =  0, $o7.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = $o7.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "errlogmat.dat", tempmat, vformvec)

				// paramquadlist: organized as iamp::0-scount
				// save as paramquadmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append($o8.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q =  0, $o8.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = $o8.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "paramquadmat.dat", tempmat, maxformvec)

				// paramloglist: organized as iamp::0-scount
				// save as paramlogmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append($o9.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q = 0, $o9.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = $o9.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "paramlogmat.dat", tempmat, maxformvec)
			}
		}

	} else {

		for r = 0, $o2.ncol-1 {
	
			for k = $o2.x[0][r], $o2.x[1][r] {

				istart += 1

				getiampdir(k, iampdir)
				
				// break up aggregate matrices into iamp-based components
				// pmat: organized iamp::0-scount
				// save as pmat
				tempmat = new Matrix($1+1, getnp())
				for sim = 0, $1 tempmat.setrow(sim, pmat.getrow(istart*(scount+1)+sim))
				// 3d() information is overly-precise; set it to float epsilon
				savemat(iampdir, "pmat.dat", tempmat, maxformvec, pheader)

				// emat: organized iamp::0-scount
				// save as emat
				tempmat = new Matrix(scount+1, nf+2)
				for sim = 0, scount tempmat.setrow(sim, emat.getrow(istart*(scount+1)+sim))
				savemat(iampdir, "emat.dat", tempmat, vformvec, eheader)

				// tmat: organized iamp::0-scount
				// save as tmat
				// additonal time statistics also produced here and saved:
				// col0 = time per simulation (hours)
				// col1 = average
				// col2 = sem = sigma/sqrt(n)
				tempmat = new Matrix(scount+1, 3)
				qstart = istart*(scount+1)
				for q = 0, tempmat.nrow-1 tempmat.x[q][0] = tmat.x[qstart+q][0]
				tempmat.x[0][1] = tempmat.getcol(0).mean
				tempmat.x[0][2] = tempmat.getcol(0).stderr
				savemat(iampdir, "tmat.dat", tempmat, tformvec, theader)

				// vmat: organized f:nf::0-scount::iamp (in cols, first col tdat)
				// save as vmat with first col tdat, cols 1-nf*(scount+1) as before: f:nf.
				tempmat = new Matrix(nrows, nf*(scount+1)+1)
				tempmat.setcol(0, tdatvec)
				for sim = 0, $1 {
					for f = 0, nf-1 {

						tempmat.setcol(nf*sim+f+1, vmat.getcol(istart*nf*(scount+1)+nf*sim+f))
					}
				}
				savemat(iampdir, "vmat.dat", tempmat, vformvec, vheader)

				// errlogmat: organized as iamp::0-scount (but of differing sizes)
				// save as errlogmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append(errloglist.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q =  0, errloglist.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = errloglist.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "errlogmat.dat", tempmat, vformvec)

				// paramquadlist: organized as iamp::0-scount
				// save as paramquadmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append(paramquadlist.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q =  0, paramquadlist.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = paramquadlist.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "paramquadmat.dat", tempmat, maxformvec)

				// paramloglist: organized as iamp::0-scount
				// save as paramlogmat
				// first get max size of vectors iamp::0-scount
				tempvec = new Vector()
				for sim = 0, scount tempvec.append(paramloglist.o(istart*(scount+1)+sim).size)
				tempmat = new Matrix(scount+1, tempvec.max)
				for sim = 0, scount {
					for q = 0, paramloglist.o(istart*(scount+1)+sim).size-1 {

						tempmat.x[sim][q] = paramloglist.o(istart*(scount+1)+sim).x[q]
					}
				}
				savemat(iampdir, "paramlogmat.dat", tempmat, maxformvec)
			}
		}
	}

	print "Simulation results saved"
}
// ---------------------------------------------------------------------------------------



// ------------------------------------parallex-------------------------------------------
// execute genopt over one or many processors.
// takes arguments setting iiamp start and iiamp end.
// no argument for default (all iiamp) or range (below)
// range mode: will solve based on range of indices provided
// from iampvec. Number of indiced must be even, i.e. (0,0), 
// (0,1), or (0,1,3,5), or (0, 3, 6, 6, 9, 12), etc.
proc parallex() {local k, sim, p, q, f, istart, upstart, qstart, qend, para, scount, scounter, total_scount, id, ind, setind, r, seed, tolopt, maxstepsizeopt localobj vvec, svec, errlogvecout, paramquadvecout, paramlogvecout, rangemat

	if (ns > simax) {

		scount = simax

	} else {

		scount = ns
	}

	if (!numarg()) {

		rangemat = new Matrix(2, 1)

		rangemat.x[0][0] = 0
		rangemat.x[1][0] = iampvec.size-1

		total_scount = (scount+1) * (iampvec.size)
	
	} else if (numarg()/2 == 1) {

		rangemat = new Matrix(2, 1)

		rangemat.x[0][0] = $1
		rangemat.x[1][0] = $2

		total_scount = (scount+1) * ($2-$1+1)
	
	} else if (numarg()/2 == 2) {

		rangemat = new Matrix(2, 2)

		rangemat.x[0][0] = $1 
		rangemat.x[1][0] = $2

		rangemat.x[0][1] = $3
		rangemat.x[1][1] = $4

		total_scount = (scount+1) * (($2-$1+1) + ($4-$3+1))
	
	} else if (numarg()/2 == 3) {

		rangemat = new Matrix(2, 3)

		rangemat.x[0][0] = $1
		rangemat.x[1][0] = $2

		rangemat.x[0][1] = $3
		rangemat.x[1][1] = $4
		
		rangemat.x[0][2] = $5
		rangemat.x[1][2] = $6

		total_scount = (scount+1) * (($2-$1+1) + ($4-$3+1) + ($6-$5+1))
	}

	scounter = 0
	istart = -1

	print "Genetic algorithm for solving cable parameters"
	print getnp(), "cable parameters found for optimization"
	print "Total simulations = ", total_scount

	setgen()
	getmutation()
	getpheader()
	croutmat(total_scount)
	croutdir()
	croutmoddir()
	seed = 0

	if (ncpu == 1) {

		para = 0
		print "Simulations will run in series..."

		for r = 0, rangemat.ncol-1 {

			for k = rangemat.x[0][r], rangemat.x[1][r] {

				croutiampdir(k)
				// croutiampdirman(k)
				mutate(seed)
				// mutate(k)
				adjust_rp()
				getiampdir(k, iampdir)
				savemat(iampdir, "rpmat.dat", rpmat, maxformvec, pheader)
				getmat(iampdir, "rpmat.dat", rpmat)

				tolopt = settol(k)
				maxstepsizeopt = setmaxstepsize(tolopt)
				istart += 1

				for sim = 0, scount {

					scounter += genopt(sim, k, rpmat.getrow(sim), para, tolopt, maxstepsizeopt, errloglist.o(istart*(scount+1)+sim), paramquadlist.o(istart*(scount+1)+sim), paramloglist.o(istart*(scount+1)+sim), scount, istart)
				}
			}
		}

		// save ser results
		if (scounter == total_scount) {

			print "\ntotal: ", scounter, "of ", total_scount, "simulations returned"
			saveopt(scount, rangemat)
			
		} else {

			print total_scount-scounter, "simulations did not return"
		}
	
	} else {

		para = 1
		print "Simulations will run in parallel..."

		for r = 0, rangemat.ncol-1 {

			for k = rangemat.x[0][r], rangemat.x[1][r] {

				croutiampdir(k)
				// croutiampdirman(k)
				mutate(seed)
				// mutate(k)
				adjust_rp()
				getiampdir(k, iampdir)
				savemat(iampdir, "rpmat.dat", rpmat, maxformvec, pheader)
				getmat(iampdir, "rpmat.dat", rpmat)

				tolopt = settol(k)
				maxstepsizeopt = setmaxstepsize(tolopt)
				istart += 1

				for sim = 0, scount {

					pc.submit("genopt", sim, k, rpmat.getrow(sim), para, tolopt, maxstepsizeopt, errloglist.o(istart*(scount+1)+sim), paramquadlist.o(istart*(scount+1)+sim), paramloglist.o(istart*(scount+1)+sim), scount, istart)
				}
		   	}
		}

		while ((id = pc.working) != 0) {

			scounter += pc.retval
			pc.take(id)
			
			ind = pc.upkscalar()
			upstart = pc.upkscalar()
			
			svec = pc.upkvec()
			vvec = pc.upkvec()
			errlogvecout = pc.upkvec()
			paramquadvecout = pc.upkvec()
			paramlogvecout = pc.upkvec()
			
			setind = upstart*(scount+1)+ind
			for p = 0, getnp()-1 pmat.x[setind][p] = svec.x[p]
			// next from svec: tsim
			tmat.x[setind][0] = svec.x[getnp()]
			// extract v from vvec into vmat
			for f = 0, nf-1 {

				qstart = f*nrows
				for q = 0, nrows-1 vmat.x[q][upstart*nf*(scount+1)+nf*ind+f] = vvec.x[qstart+q]
			}
			// errloglist
			errloglist.o(setind).resize(errlogvecout.size)
			for q = 0, errlogvecout.size-1 errloglist.o(setind).x[q] = errlogvecout.x[q]
			// emat: individual errors in cols 0,nf-1
			for f = 0, nf-1 emat.x[setind][f] = errlogvecout.x[errlogvecout.size+errlogvecout.x[errlogvecout.size-1]-nf+f]
			// add total error at col nf
			emat.x[setind][nf] = errlogvecout.x[errlogvecout.size+errlogvecout.x[errlogvecout.size-1]]
			// add tol at col nf+1
			emat.x[setind][nf+1] = errlogvecout.x[errlogvecout.size-1-1]
			// paramquadlist
			paramquadlist.o(setind).resize(paramquadvecout.size)
			for q = 0, paramquadvecout.size-1 paramquadlist.o(setind).x[q] = paramquadvecout.x[q]
			// paramloglist
			paramloglist.o(setind).resize(paramlogvecout.size)
			for q = 0, paramlogvecout.size-1 paramloglist.o(setind).x[q] = paramlogvecout.x[q]
		}

		// this is where parallel jobs end
		pc.done()
		
		// check returned simulations and save
		if (scounter == total_scount) {

			print "\ntotal: ", scounter, "of ", total_scount, "simulations returned"
			saveopt(scount, rangemat, pmat, emat, tmat, vmat, errloglist, paramquadlist, paramloglist)
				
		} else {

			print total_scount-scounter, "simulations did not return. Interim results not saved."
		}
	}
}
// ---------------------------------------------------------------------------------------
